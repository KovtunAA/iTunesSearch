//
//  ListInteractor.swift
//  testTask
//
//  Created by Mac on 4/27/18.
//  Copyright (c) 2018 kovtuns. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ListBusinessLogic {
    func getList(_ excludeWord: String)
    func getFilteredList(_ searchText: String,_ initList: [List.Model.ViewModel.Video])
}

protocol ListDataStore {
}

class ListInteractor: ListDataStore {
    var presenter: ListPresentationLogic?
    var worker: ListWorker?
}

extension ListInteractor: ListBusinessLogic{
    // MARK: - ListBusinessLogic Delegate
    
    func getFilteredList(_ searchText: String,_ initList: [List.Model.ViewModel.Video]) {
        let filteredList = initList.filter({( video : List.Model.ViewModel.Video) -> Bool in
            return (video.name ?? "").lowercased().contains(searchText.lowercased())
        })
        
        var response = List.Model.Response()
        response.filteredVideo = filteredList

        self.presenter?.presentFilteredList(response: response)
    }
    
    func getList(_ excludeWord: String){
        worker = ListWorker()
        let request = List.Model.Request(term: "michael+jackson", media: "musicVideo")
        
        worker?.getSearchResult(request: request, { (data, error) in
            ProgressLoader.hide {
                var response = List.Model.Response()
                
                guard error == nil else{
                    response.error = error
                    self.presenter?.presentError(response: response)
                    return
                }
                
                guard data != nil else{
                    response.error = CustomError.dataFailed
                    self.presenter?.presentError(response: response)
                    return
                }
                if let array = data!["results"]{
                    do{
                        let dataArray = try JSONSerialization.data(withJSONObject: array, options: .prettyPrinted)
                        do {
                            let videos = try JSONDecoder().decode([Video].self, from: dataArray)

                            response.video = self.filteringVideos(videos: videos, excludeKey: excludeWord)
                            self.presenter?.presentData(response: response)
                        } catch {
                            response.error = CustomError.dataFailed
                            self.presenter?.presentError(response: response)
                        }
                    } catch {
                        response.error = CustomError.dataFailed
                        self.presenter?.presentError(response: response)
                    }
                }
            }
        })
    }

    func filteringVideos(videos: [Video], excludeKey: String) -> [Video] {
        return videos.filter({( video : Video) -> Bool in
            return !((video.trackCensoredName ?? "").lowercased().contains(excludeKey.lowercased()))
        })
    }
}
